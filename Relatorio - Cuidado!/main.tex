%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lachaise Assignment
% LaTeX Template
% Version 1.0 (26/6/2018)
%
% This template originates from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Marion Lachaise & François Févotte
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Computação Gráfica: Etapa\#1} % Title of the assignment

\author{Bernardo Rodrigues\\ \texttt{a99999@alunos.uminho.pt}\\ \and César Silva\\ \texttt{a77518@alunos.uminho.pt}\\ \and Pedro Faria\\ \texttt{a82725@alunos.uminho.pt} \and Rui Silva\\ \texttt{a99999@alunos.uminho.pt}\\} % Author name and email address

\date{Universidade do Minho --- \today} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle 
% meter uma imagem toda catita aqui
\newpage

\begin{abstract}
A \textbf{Computação Gráfica}, uma das muitas áreas da informática, que assume um papel fulcral em interações homem-máquina e na visualização de dados. o seu espectro de aplicações varia desde geração de imagens até a simulação do mundo real.
O presente relatório refere-se à primeira fase de entrega da componente prática da unidade curricular (UC) de \textbf{Computação Gráfica} enquadrada no curso de Ciências da Computação da Universidade do Minho.
\end{abstract}
\newpage

%-------------------------------------------------
% 		METER A QUOTE AQUI
%-------------------------------------------------

\tableofcontents{}
\newpage

%-------------------------------------------------
%		Introducao
%-------------------------------------------------

\section{Introdução}

Nesta fase, foram desenvolvidas duas aplicações. Um gerador de modelos, que aceite argumentos a partir do terminal, que nesta fase deveria escrever para um documento os pontos de uma primitiva gráfica desejada pelo utilizador. E a última, um motor capaz de gerar os modelos a partir de um ficheiro de configuração. 
Com base nos tópicos enunciados nas aulas teóricas e ferramentas exploradas nas aulas práticas. Implementamos o gerador e o motor na linguagem \textbf{C++[]}, em particular esta última faz uso de biblioteca \textbf{TinyXML2} para que a leitura dos documentos que lhe são dados com input seja feita de forma simples e consistente. E por fim,  utilizamos a API fornecida pelo \textbf{OpenGl} para dar vida aos nossos modelos e confirmar a consistência dos nossos programas.

\subsection{Análise do Enunciado}

Talvez remover esta ainda vamos ver.

\subsection{Estrutura do Relatório}

bla bla

\section{Gerador}
O nosso \textbf{Gerador} é um pequeno programa em \textbf{C++} que depois de compilado, o correspondente executável escreve para um ficheiro (um por linha) os vértices da primitiva gráfica desejada  como iremos ilustrar nas seguintes secções.
% Linha de Comandos "screenshot"
\begin{commandline}
	\begin{verbatim}
		$ g++ -o gerador gen.cpp
		$ ./gerador cone 1 1 20 5
		$ ls
		$ gen.cpp			gerador			cone.txt
	\end{verbatim}
\end{commandline}
\subsection{Caixa}

\subsection{Cone}

\subsection{Esfera}

\subsection{Plano}

\section{Motor}
O motor é a parte do nosso trabalho que faz o linking de todas as outras partes que foram realizadas. O motor, lê um ficheiro xml (conf.xml). Este ficheiro contém uma estrutura bastante simples, dividida em scenes.

% Contents do ficheiro conf.xml
\begin{file}[conf.xml]
	\begin{lstlisting}[language=XML]
	<scene>
		<model file="esfera.txt" />
		<model file="cone.txt" />
		<model file="caixa.txt" />
	</scene>
	\end{lstlisting}
	\end{file}

Cada ficheiro que está referenciado nas tags \textbf{<model>} é um ficheiro de texto criado pelo nosso gerador e contém todos os pontos das figuras que queremos representar.
Como o motor lê os ficheiros de pontos a partir dum ficheiro \textbf{XML} utilizamos um parser xml para \textbf{C++} chamado \textbf{tinyxml-2}.

\begin{file}[main.cpp]
	\begin{lstlisting}[language=C++]
...
tinyxml2::XMLDocument doc;

doc.LoadFile("./conf.xml");

tinyxml2::XMLNode *scene = doc.FirstChild();
		
tinyxml2::XMLElement* model;

while(scene) {
	for(model = scene->FirstChildElement();
	model != NULL; 
	model = model->NextSiblingElement()) {
		const char * file;
		file = model->Attribute("file");
		guardaPontos(file);
	}
	scene = scene->NextSiblingElement();
}
...

	\end{lstlisting}
\end{file}

Com este snippet de código, criamos um objeto do tipo XMLDocument. De seguida, com a função \textbf{LoadFile}, abrimos o ficheiro de configuração \textbf{conf.xml}, e começamos a manipular o seu conteúdo.
Criamos um objeto do tipo \textbf{XMLNode} e associamos-lhe a primeira \textbf{tag} do ficheiro conf.xml que é a raiz da estrutura do nosso ficheiro.
No ciclo while, percorremos todos o ChildElements de scene, que são as tags que guardam os nossos ficheiros das figuras.
Cada ficheiro de figura tirado dos \textbf{models} é passado à função \textbf{guardaPontos}, que será explicada de seguida.

\begin{file}[main.cpp]
	\begin{lstlisting}[language=C++]
...
struct Pontos {
    float a;
    float b;
    float c;
};

std::vector<Pontos> pontos;

void guardaPontos(std::string ficheiro) {
	std::ifstream file;
	std::string s = "./";
	s.append(ficheiro.c_str());
	file.open(s.c_str());
	float a,b,c;
	while(file >> a >> b >> c) {
		Pontos aux;
		aux.a = a;
		aux.b = b;
		aux.c = c;
		pontos.push_back(aux);
	}
}
...
	\end{lstlisting}
\end{file}

Criamos uma estrutura \textbf{Pontos} que tem como campos 3 \textit{floats}, que servem para registar as coordenadas destes. De seguida usamos um vector que utiliza a estrutura enunciada para os guardar.
À função \textbf{guardaPontos} são passados nomes de ficheiros. A função abre os ficheiros e lê pontos linha a linha, guardando cada coordenada \textit{x, y e z} num \textbf{Ponto} e de seguida inserindo-o no vector.

\begin{info} % Information block
	A instrução:
	\begin{lstlisting}[language=C++]
		file >> a >> b >> c
	\end{lstlisting}
	associa a cada uma das variaveis \textit{a, b} e \textit{c}, as coordenadas da linha que está a ser lida em cada iteração do ciclo.
\end{info}

Por ultimo temos a função \textbf{printPontos}:

\begin{file}[main.cpp]
	\begin{lstlisting}[language=C++]
...
void printPontos(std::vector<Pontos> pontos) {
  for(int i = 0; i < pontos.size(); i++) {
		glVertex3f(pontos[i].a,
			pontos[i].b, 
			pontos[i].c);
	}
}
...
	\end{lstlisting}
\end{file}

Esta função é chamada na \text{renderScene} e geras todos os pontos percorrendo o vector.


\section{Conclusão}
De um modo geral achamos que grupo, apesar das dificuldades,  correspondeu às exigências propostas do enunciado. Tentamos implementar uma solução que suportasse requisitos futuros.  
\appendix

\section{Coisas que se pode fazer com este template}

% Numbered question, with subquestions in an enumerate environment
\begin{question}
	Quisque ullamcorper placerat ipsum. Cras nibh. Morbi vel justo vitae lacus tincidunt ultrices. Lorem ipsum dolor sit amet, consectetuer adipiscing elit.

	% Subquestions numbered with letters
	\begin{enumerate}[(a)]
		\item Do this.
		\item Do that.
		\item Do something else.
	\end{enumerate}
\end{question}
	
\begin{center}
	\begin{minipage}{0.5\linewidth} % Adjust the minipage width to accomodate for the length of algorithm lines
		\begin{algorithm}[H]
			\KwIn{$(a, b)$, two floating-point numbers}  % Algorithm inputs
			\KwResult{$(c, d)$, such that $a+b = c + d$} % Algorithm outputs/results
			\medskip
			\If{$\vert b\vert > \vert a\vert$}{
				exchange $a$ and $b$ \;
			}
			$c \leftarrow a + b$ \;
			$z \leftarrow c - a$ \;
			$d \leftarrow b - z$ \;
			{\bf return} $(c,d)$ \;
			\caption{\texttt{FastTwoSum}} % Algorithm name
			\label{alg:fastTwoSum}   % optional label to refer to
		\end{algorithm}
	\end{minipage}
\end{center}

% Numbered question, with an optional title
\begin{question}[\itshape (with optional title)]
	In congue risus leo, in gravida enim viverra id. Donec eros mauris, bibendum vel dui at, tempor commodo augue. In vel lobortis lacus. Nam ornare ullamcorper mauris vel molestie. Maecenas vehicula ornare turpis, vitae fringilla orci consectetur vel. Nam pulvinar justo nec neque egestas tristique. Donec ac dolor at libero congue varius sed vitae lectus. Donec et tristique nulla, sit amet scelerisque orci. Maecenas a vestibulum lectus, vitae gravida nulla. Proin eget volutpat orci. Morbi eu aliquet turpis. Vivamus molestie urna quis tempor tristique. Proin hendrerit sem nec tempor sollicitudin.
\end{question}

% Math equation/formula
\begin{equation}
	I = \int_{a}^{b} f(x) \; \text{d}x.
\end{equation}

\begin{info} % Information block
	This is an interesting piece of information, to which the reader should pay special attention. Fusce varius orci ac magna dapibus porttitor. In tempor leo a neque bibendum sollicitudin. Nulla pretium fermentum nisi, eget sodales magna facilisis eu. Praesent aliquet nulla ut bibendum lacinia. Donec vel mauris vulputate, commodo ligula ut, egestas orci. Suspendisse commodo odio sed hendrerit lobortis. Donec finibus eros erat, vel ornare enim mattis et.
\end{info}

% File contents
\begin{file}[hello.py]
\begin{lstlisting}[language=Python]
#! /usr/bin/python

import sys
sys.stdout.write("Hello World!\n")
\end{lstlisting}
\end{file}

% Command-line "screenshot"
\begin{commandline}
	\begin{verbatim}
		$ chmod +x hello.py
		$ ./hello.py

		Hello World!
	\end{verbatim}
\end{commandline}


% Warning text, with a custom title
\begin{warn}[Notice:]
  In congue risus leo, in gravida enim viverra id. Donec eros mauris, bibendum vel dui at, tempor commodo augue. In vel lobortis lacus. Nam ornare ullamcorper mauris vel molestie. Maecenas vehicula ornare turpis, vitae fringilla orci consectetur vel. Nam pulvinar justo nec neque egestas tristique. Donec ac dolor at libero congue varius sed vitae lectus. Donec et tristique nulla, sit amet scelerisque orci. Maecenas a vestibulum lectus, vitae gravida nulla. Proin eget volutpat orci. Morbi eu aliquet turpis. Vivamus molestie urna quis tempor tristique. Proin hendrerit sem nec tempor sollicitudin.
\end{warn}


\end{document}
